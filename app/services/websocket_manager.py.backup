"""
WebSocket Manager v2.2 - Real-time Binance Data Stream
‡πÅ‡∏ö‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô 5 Layers ‡∏´‡∏•‡∏±‡∏Å
"""
import logging
import json
import time
import threading
from typing import Callable, Optional, Dict
import websocket

logger = logging.getLogger(__name__)


# ============================================================================
# LAYER 1: Configuration & Initialization
# ============================================================================
class WebSocketManager:
    """
    ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ WebSocket connection ‡∏Å‡∏±‡∏ö Binance
    ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö: 15m, 1h kline streams ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö BTC Rebound
    """
    
    def __init__(self, symbol: str = "btcusdt", timeframe: str = "15m"):
        """
        ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô WebSocket Manager
        
        Args:
            symbol: ‡∏Ñ‡∏π‡πà‡πÄ‡∏ó‡∏£‡∏î ‡πÄ‡∏ä‡πà‡∏ô btcusdt, ethusdt
            timeframe: ‡∏Å‡∏£‡∏≠‡∏ö‡πÄ‡∏ß‡∏•‡∏≤ ‡πÄ‡∏ä‡πà‡∏ô 15m, 1h, 5m
        """
        # Config
        self.symbol = symbol.lower()
        self.timeframe = timeframe.lower()
        self.base_url = "wss://stream.binance.com:9443/ws"
        self.stream_name = f"{self.symbol}@kline_{self.timeframe}"
        
        # WebSocket instance
        self.ws = None
        self.ws_thread = None
        
        # State management
        self.is_running = False
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 10
        self.reconnect_delay = 5  # ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
        
        # Callback ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ
        self.on_kline_callback: Optional[Callable] = None
        
        logger.info(f"WebSocketManager initialized: {self.stream_name}")


# ============================================================================
# LAYER 2: WebSocket Connection Management
# ============================================================================
    
    def connect(self):
        """‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ WebSocket ‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏° listen"""
        if self.is_running:
            logger.warning("WebSocket already running")
            return
        
        self.is_running = True
        self.reconnect_attempts = 0
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á WebSocket connection
        ws_url = f"{self.base_url}/{self.stream_name}"
        logger.info(f"Connecting to: {ws_url}")
        
        self.ws = websocket.WebSocketApp(
            ws_url,
            on_message=self._on_message,
            on_error=self._on_error,
            on_close=self._on_close,
            on_open=self._on_open
        )
        
        # ‡∏£‡∏±‡∏ô‡πÉ‡∏ô thread ‡πÅ‡∏¢‡∏Å
        self.ws_thread = threading.Thread(
            target=self._run_websocket,
            daemon=True
        )
        self.ws_thread.start()
        
        logger.info("WebSocket thread started")
    
    def _run_websocket(self):
        """‡∏£‡∏±‡∏ô WebSocket loop (‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÉ‡∏ô thread)"""
        try:
            self.ws.run_forever(
                ping_interval=20,  # ‡∏™‡πà‡∏á ping ‡∏ó‡∏∏‡∏Å 20 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
                ping_timeout=10     # timeout 10 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
            )
        except Exception as e:
            logger.error(f"WebSocket run error: {e}")
            self._attempt_reconnect()
    
    def disconnect(self):
        """‡∏ï‡∏±‡∏î WebSocket connection"""
        logger.info("Disconnecting WebSocket...")
        self.is_running = False
        
        if self.ws:
            self.ws.close()
        
        logger.info("WebSocket disconnected")


# ============================================================================
# LAYER 3: Message Handling (‡∏™‡πà‡∏ß‡∏ô‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)
# ============================================================================
    
    def _on_message(self, ws, message):
        """
        ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• kline ‡∏à‡∏≤‡∏Å Binance
        
        Message format:
        {
            "e": "kline",
            "s": "BTCUSDT",
            "k": {
                "t": 1234567890,  # open time
                "o": "50000.00",   # open
                "h": "51000.00",   # high
                "l": "49000.00",   # low
                "c": "50500.00",   # close
                "v": "100.50",     # volume
                "x": true          # is candle closed
            }
        }
        """
        logger.info("üîî Message received")  # Debug
        
        Message format:
        {
            "e": "kline",
            "s": "BTCUSDT",
            "k": {
                "t": 1234567890,  # open time
                "o": "50000.00",   # open
                "h": "51000.00",   # high
                "l": "49000.00",   # low
                "c": "50500.00",   # close
                "v": "100.50",     # volume
                "x": true          # is candle closed
            }
        }
        """
        try:
            data = json.loads(message)
            
            # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô kline event
            if data.get("e") != "kline":
                return
            
            kline = data.get("k", {})
            
            # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢
            kline_data = {
                "symbol": data.get("s"),
                "timeframe": self.timeframe,
                "open_time": kline.get("t"),
                "close_time": kline.get("T"),
                "open": float(kline.get("o", 0)),
                "high": float(kline.get("h", 0)),
                "low": float(kline.get("l", 0)),
                "close": float(kline.get("c", 0)),
                "volume": float(kline.get("v", 0)),
                "is_closed": kline.get("x", False)  # ‡πÅ‡∏ó‡πà‡∏á‡∏õ‡∏¥‡∏î‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
            }
            
            # ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡πÉ‡∏´‡πâ callback (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
            if self.on_kline_callback:
                self.on_kline_callback(kline_data)
            
            # Log ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÅ‡∏ó‡πà‡∏á‡∏ó‡∏µ‡πà‡∏õ‡∏¥‡∏î
            if kline_data["is_closed"]:
                logger.info(
                    f"üïØÔ∏è Kline closed: {kline_data['symbol']} {self.timeframe} "
                    f"C: {kline_data['close']:.2f}"
                )
                
        except Exception as e:
            logger.error(f"Error processing message: {e}")
    
    def _on_open(self, ws):
        """‡πÄ‡∏°‡∏∑‡πà‡∏≠ WebSocket ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à"""
        logger.info(f"‚úÖ WebSocket connected: {self.stream_name}")
        self.reconnect_attempts = 0
    
    def _on_error(self, ws, error):
        """‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏Å‡∏¥‡∏î error"""
        logger.error(f"‚ùå WebSocket error: {error}")
    
    def _on_close(self, ws, close_status_code, close_msg):
        """‡πÄ‡∏°‡∏∑‡πà‡∏≠ WebSocket ‡∏õ‡∏¥‡∏î"""
        logger.warning(
            f"üîå WebSocket closed: {close_status_code} - {close_msg}"
        )
        logger.warning(f"üîç Debug: is_running={self.is_running}, reconnect_attempts={self.reconnect_attempts}")
        
        # ‡∏•‡∏≠‡∏á reconnect ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà
        if self.is_running:
            logger.info("üîÑ Initiating reconnect...")
            self._attempt_reconnect()
        else:
            logger.warning("‚ö†Ô∏è Not reconnecting (is_running=False)")


# ============================================================================
# LAYER 4: Reconnection Logic
# ============================================================================
    
    def _attempt_reconnect(self):
        """‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏° reconnect ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥"""
        if self.reconnect_attempts >= self.max_reconnect_attempts:
            logger.error(
                f"Max reconnect attempts ({self.max_reconnect_attempts}) reached. "
                "Giving up."
            )
            self.is_running = False
            return
        
        self.reconnect_attempts += 1
        wait_time = self.reconnect_delay * self.reconnect_attempts
        
        logger.info(
            f"üîÑ Reconnect attempt {self.reconnect_attempts}/"
            f"{self.max_reconnect_attempts} in {wait_time}s..."
        )
        
        time.sleep(wait_time)
        
        if self.is_running:
            self.ws = None
            ws_url = f"{self.base_url}/{self.stream_name}"
            logger.info(f"Reconnecting to: {ws_url}")
            
            self.ws = websocket.WebSocketApp(
                ws_url,
                on_message=self._on_message,
                on_error=self._on_error,
                on_close=self._on_close,
                on_open=self._on_open
            )
            
            self.ws_thread = threading.Thread(
                target=self._run_websocket,
                daemon=True
            )
            self.ws_thread.start()


# ============================================================================
# LAYER 5: Public Interface (‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å)
# ============================================================================
    
    def set_kline_callback(self, callback: Callable):
        """
        ‡∏ï‡∏±‡πâ‡∏á callback ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• kline
        
        Args:
            callback: ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö dict ‡∏Ç‡∏≠‡∏á kline_data
        
        Example:
            def my_callback(kline_data):
                print(f"Price: {kline_data['close']}")
            
            ws_manager.set_kline_callback(my_callback)
        """
        self.on_kline_callback = callback
        logger.info("Kline callback registered")
    
    def get_status(self) -> Dict:
        """‡∏î‡∏π‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ WebSocket"""
        return {
            "is_running": self.is_running,
            "stream": self.stream_name,
            "reconnect_attempts": self.reconnect_attempts,
            "thread_alive": self.ws_thread.is_alive() if self.ws_thread else False
        }
    
    def change_stream(self, symbol: str, timeframe: str):
        """
        ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô stream (‡∏ï‡πâ‡∏≠‡∏á disconnect ‡πÅ‡∏•‡∏∞ connect ‡πÉ‡∏´‡∏°‡πà)
        
        Args:
            symbol: ‡∏Ñ‡∏π‡πà‡πÄ‡∏ó‡∏£‡∏î‡πÉ‡∏´‡∏°‡πà
            timeframe: timeframe ‡πÉ‡∏´‡∏°‡πà
        """
        logger.info(f"Changing stream to {symbol}@kline_{timeframe}")
        
        # ‡∏õ‡∏¥‡∏î‡πÄ‡∏î‡∏¥‡∏°
        self.disconnect()
        time.sleep(2)
        
        # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡∏°‡πà
        self.symbol = symbol.lower()
        self.timeframe = timeframe.lower()
        self.stream_name = f"{self.symbol}@kline_{self.timeframe}"
        
        # ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡πÉ‡∏´‡∏°‡πà
        self.connect()


# ============================================================================
# HELPER: ‡∏ó‡∏î‡∏™‡∏≠‡∏ö WebSocket ‡πÅ‡∏¢‡∏Å
# ============================================================================
def test_websocket():
    """‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏î‡∏™‡∏≠‡∏ö WebSocket ‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢"""
    def on_kline(data):
        print(f"üìä {data['symbol']} {data['timeframe']}")
        print(f"   Open: {data['open']:.2f}")
        print(f"   High: {data['high']:.2f}")
        print(f"   Low: {data['low']:.2f}")
        print(f"   Close: {data['close']:.2f}")
        print(f"   Closed: {data['is_closed']}")
        print()
    
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á WebSocket Manager
    ws_manager = WebSocketManager(symbol="btcusdt", timeframe="15m")
    ws_manager.set_kline_callback(on_kline)
    ws_manager.connect()
    
    # ‡∏£‡∏±‡∏ô‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏Å‡∏î Ctrl+C
    try:
        print("WebSocket running... Press Ctrl+C to stop")
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("\nStopping...")
    finally:
        ws_manager.disconnect()


if __name__ == "__main__":
    # ‡∏ó‡∏î‡∏™‡∏≠‡∏ö
    test_websocket()